_xyY_to_munsell_specification source:
================================================================================
def _xyY_to_munsell_specification(xyY: ArrayLike) -> NDArrayFloat:
    """
    Convert from *CIE xyY* colourspace to *Munsell* *Colorlab* specification.

    Parameters
    ----------
    xyY
        *CIE xyY* colourspace array.

    Returns
    -------
    :class:`numpy.NDArrayFloat`
        *Munsell* *Colorlab* specification.

    Raises
    ------
    ValueError
        If the given *CIE xyY* colourspace array is not within MacAdam
        limits.
    RuntimeError
        If the maximum iterations count has been reached without converging to
        a result.
    """

    xyY = as_float_array(xyY)

    x, y, Y = tsplit(xyY)
    Y = to_domain_1(Y)

    if not is_within_macadam_limits(xyY, ILLUMINANT_NAME_MUNSELL):
        usage_warning(
            f'"{xyY!r}" is not within "MacAdam" limits for illuminant '
            f'"{ILLUMINANT_NAME_MUNSELL}"!'
        )

    with domain_range_scale("ignore"):
        value = munsell_value_ASTMD1535(Y * 100)

    if is_integer(value):
        value = np.around(value)

    with domain_range_scale("ignore"):
        x_center, y_center, Y_center = tsplit(_munsell_specification_to_xyY(value))

    rho_input, phi_input, _z_input = tsplit(
        cartesian_to_cylindrical([x - x_center, y - y_center, Y_center])
    )
    phi_input = np.degrees(phi_input)

    grey_threshold = THRESHOLD_INTEGER
    if rho_input < grey_threshold:
        return from_range_10(normalise_munsell_specification(value))

    XYZ = xyY_to_XYZ(xyY)

    _X, Y, _Z = tsplit(XYZ)
    x_i, y_i = CCS_ILLUMINANT_MUNSELL
    X_r, Y_r, Z_r = xyY_to_XYZ([x_i, y_i, Y])

    with sdiv_mode():
        XYZ_r = np.array([(1 / Y_r) * X_r, 1, (1 / Y_r) * Z_r])

    Lab = XYZ_to_Lab(XYZ, XYZ_to_xy(XYZ_r))
    LCHab = Lab_to_LCHab(Lab)
    hue_initial, _value_initial, chroma_initial, code_initial = tsplit(
        LCHab_to_munsell_specification(LCHab)
    )
    specification_current = [
        hue_initial,
        value,
        (5 / 5.5) * chroma_initial,
        code_initial,
    ]

    convergence_threshold = THRESHOLD_INTEGER / 1e4
    iterations_maximum = 64
    iterations = 0

    while iterations <= iterations_maximum:
        iterations += 1

        (
            hue_current,
            _value_current,
            chroma_current,
            code_current,
        ) = specification_current
        hue_angle_current = hue_to_hue_angle([hue_current, code_current])

        chroma_maximum = maximum_chroma_from_renotation(
            [hue_current, value, code_current]
        )
        if chroma_current > chroma_maximum:
            chroma_current = specification_current[2] = chroma_maximum

        with domain_range_scale("ignore"):
            x_current, y_current, _Y_current = tsplit(
                _munsell_specification_to_xyY(specification_current)
            )

        rho_current, phi_current, _z_current = tsplit(
            cartesian_to_cylindrical(
                [x_current - x_center, y_current - y_center, Y_center]
            )
        )
        phi_current = np.degrees(phi_current)
        phi_current_difference = (360 - phi_input + phi_current) % 360
        if phi_current_difference > 180:
            phi_current_difference -= 360

        phi_differences_data = [phi_current_difference]
        hue_angles_differences_data = [0]
        hue_angles = [hue_angle_current]

        iterations_maximum_inner = 16
        iterations_inner = 0
        extrapolate = False

        while (
            np.sign(np.min(phi_differences_data))
            == np.sign(np.max(phi_differences_data))
            and extrapolate is False
        ):
            iterations_inner += 1

            if iterations_inner > iterations_maximum_inner:
                # NOTE: This exception is likely never raised in practice:
                # 300K iterations with random numbers never reached this code
                # path, it is kept for consistency with the reference
                # implementation.
                raise RuntimeError(  # pragma: no cover
                    "Maximum inner iterations count reached without convergence!"
                )

            hue_angle_inner = (
                hue_angle_current + iterations_inner * (phi_input - phi_current)
            ) % 360
            hue_angle_difference_inner = (
                iterations_inner * (phi_input - phi_current) % 360
            )
            if hue_angle_difference_inner > 180:
                hue_angle_difference_inner -= 360

            hue_inner, code_inner = hue_angle_to_hue(hue_angle_inner)

            with domain_range_scale("ignore"):
                x_inner, y_inner, _Y_inner = _munsell_specification_to_xyY(
                    [
                        hue_inner,
                        value,
                        chroma_current,  # pyright: ignore
                        code_inner,
                    ]
                )

            if len(phi_differences_data) >= 2:
                extrapolate = True

            if extrapolate is False:
                rho_inner, phi_inner, _z_inner = cartesian_to_cylindrical(
                    [x_inner - x_center, y_inner - y_center, Y_center]
                )
                phi_inner = np.degrees(phi_inner)
                phi_inner_difference = (360 - phi_input + phi_inner) % 360
                if phi_inner_difference > 180:
                    phi_inner_difference -= 360

                phi_differences_data.append(phi_inner_difference)
                hue_angles.append(hue_angle_inner)
                hue_angles_differences_data.append(hue_angle_difference_inner)

        phi_differences = np.array(phi_differences_data)
        hue_angles_differences = np.array(hue_angles_differences_data)

        phi_differences_indexes = phi_differences.argsort()

        phi_differences = phi_differences[phi_differences_indexes]
        hue_angles_differences = hue_angles_differences[phi_differences_indexes]

        hue_angle_difference_new = (
            Extrapolator(LinearInterpolator(phi_differences, hue_angles_differences))(0)
            % 360
        )
        hue_angle_new = cast(
            float, (hue_angle_current + hue_angle_difference_new) % 360
        )

        hue_new, code_new = hue_angle_to_hue(hue_angle_new)
        specification_current = [hue_new, value, chroma_current, code_new]

        with domain_range_scale("ignore"):
            x_current, y_current, _Y_current = _munsell_specification_to_xyY(
                specification_current
            )

        chroma_scale = 50 if get_domain_range_scale() == "1" else 2

        difference = euclidean_distance([x, y], [x_current, y_current])
        if difference < convergence_threshold:
            return from_range_10(
                np.array(specification_current),
                np.array([10, 10, chroma_scale, 10]),
            )

        # TODO: Consider refactoring implementation.
        (
            hue_current,
            _value_current,
            chroma_current,
            code_current,
        ) = specification_current
        chroma_maximum = maximum_chroma_from_renotation(
            [hue_current, value, code_current]
        )

        # NOTE: This condition is likely never "True" while producing a valid
        # "Munsell Specification" in practice: 100K iterations with random
        # numbers never reached this code path while producing a valid
        # "Munsell Specification".
        if chroma_current > chroma_maximum:
            chroma_current = specification_current[2] = chroma_maximum

        with domain_range_scale("ignore"):
            x_current, y_current, _Y_current = _munsell_specification_to_xyY(
                specification_current
            )

        rho_current, phi_current, _z_current = cartesian_to_cylindrical(
            [x_current - x_center, y_current - y_center, Y_center]
        )

        rho_bounds_data = [rho_current]
        chroma_bounds_data = [chroma_current]

        iterations_maximum_inner = 16
        iterations_inner = 0
        while not (np.min(rho_bounds_data) < rho_input < np.max(rho_bounds_data)):
            iterations_inner += 1

            if iterations_inner > iterations_maximum_inner:
                raise RuntimeError(
                    "Maximum inner iterations count reached without convergence!"
                )

            with sdiv_mode():
                chroma_inner = (
                    (rho_input / rho_current) ** iterations_inner
                ) * chroma_current

            if chroma_inner > chroma_maximum:
                chroma_inner = specification_current[2] = chroma_maximum

            specification_inner = [
                hue_current,
                value,
                chroma_inner,
                code_current,
            ]

            with domain_range_scale("ignore"):
                x_inner, y_inner, _Y_inner = _munsell_specification_to_xyY(
                    specification_inner
                )

            rho_inner, phi_inner, _z_inner = cartesian_to_cylindrical(
                [x_inner - x_center, y_inner - y_center, Y_center]
            )

            rho_bounds_data.append(rho_inner)
            chroma_bounds_data.append(chroma_inner)

        rho_bounds = np.array(rho_bounds_data)
        chroma_bounds = np.array(chroma_bounds_data)

        rhos_bounds_indexes = rho_bounds.argsort()

        rho_bounds = rho_bounds[rhos_bounds_indexes]
        chroma_bounds = chroma_bounds[rhos_bounds_indexes]
        chroma_new = LinearInterpolator(rho_bounds, chroma_bounds)(rho_input)

        specification_current = [hue_current, value, chroma_new, code_current]

        with domain_range_scale("ignore"):
            x_current, y_current, _Y_current = _munsell_specification_to_xyY(
                specification_current
            )

        difference = euclidean_distance([x, y], [x_current, y_current])
        if difference < convergence_threshold:
            return from_range_10(
                np.array(specification_current),
                np.array([10, 10, chroma_scale, 10]),
            )

    # NOTE: This exception is likely never raised in practice: 300K iterations
    # with random numbers never reached this code path, it is kept for
    # consistency with the reference # implementation
    raise RuntimeError(  # pragma: no cover
        "Maximum outside iterations count reached without convergence!"
    )


================================================================================
xyY_to_munsell_specification wrapper:
================================================================================
def xyY_to_munsell_specification(xyY: ArrayLike) -> NDArrayFloat:
    """
    Convert from *CIE xyY* colourspace to *Munsell* *Colorlab* specification.

    Parameters
    ----------
    xyY
        *CIE xyY* colourspace array.

    Returns
    -------
    :class:`numpy.NDArrayFloat`
        *Munsell* *Colorlab* specification.

    Raises
    ------
    ValueError
        If the given *CIE xyY* colourspace array is not within MacAdam
        limits.
    RuntimeError
        If the maximum iterations count has been reached without converging to
        a result.

    Notes
    -----
    +-------------------+-----------------------+---------------+
    | **Domain**        | **Scale - Reference** | **Scale - 1** |
    +===================+=======================+===============+
    | ``xyY``           | [0, 1]                | [0, 1]        |
    +-------------------+-----------------------+---------------+

    +-------------------+-----------------------+---------------+
    | **Range**         | **Scale - Reference** | **Scale - 1** |
    +===================+=======================+===============+
    | ``specification`` | ``hue``    : [0, 10]  | [0, 1]        |
    |                   |                       |               |
    |                   | ``value``  : [0, 10]  | [0, 1]        |
    |                   |                       |               |
    |                   | ``chroma`` : [0, 50]  | [0, 1]        |
    |                   |                       |               |
    |                   | ``code``   : [0, 10]  | [0, 1]        |
    +-------------------+-----------------------+---------------+

    References
    ----------
    :cite:`Centore2014p`

    Examples
    --------
    >>> xyY = np.array([0.38736945, 0.35751656, 0.59362000])
    >>> xyY_to_munsell_specification(xyY)  # doctest: +ELLIPSIS
    array([ 4.2000019...,  8.0999999...,  5.2999996...,  6.        ])
    """

    xyY = as_float_array(xyY)
    shape = list(xyY.shape)

    specification = [_xyY_to_munsell_specification(a) for a in np.reshape(xyY, (-1, 3))]

    shape[-1] = 4

    return np.reshape(as_float_array(specification), shape)

